// Package resolver contains the resolver
package resolver

import (
	"context"
	"time"

	"github.com/ooni/netx/model"
)

type contextkey struct{}

// WithDialID returns a copy of ctx with the specified dialID
func WithDialID(ctx context.Context, dialID int64) context.Context {
	return context.WithValue(ctx, contextkey{}, dialID)
}

// ContextDialID returns the dialID of the context, or zero
func ContextDialID(ctx context.Context) int64 {
	id, _ := ctx.Value(contextkey{}).(int64)
	return id
}

// Generic is a generic resolver
type Generic interface {
	LookupHost(ctx context.Context, hostname string) ([]string, error)
}

// Resolver is a resolver
type Resolver struct {
	beginning time.Time
	handler   model.Handler
	resolver  Generic
}

// New creates a new resolver
func New(
	beginning time.Time,
	handler model.Handler,
	resolver Generic,
) *Resolver {
	return &Resolver{
		beginning: beginning,
		handler:   handler,
		resolver:  resolver,
	}
}

// LookupHost resolves a specific hostname
func (r *Resolver) LookupHost(
	ctx context.Context, hostname string,
) ([]string, error) {
	// When we're using DoH we have a `ctx` that is already
	// prepared for HTTP measurements. So, using the same `ctx`
	// leads to completely messy results. Instead, separate
	// the contexts but still honour cancellation here.
	ch := make(chan result, 1)
	child, cancel := context.WithCancel(context.Background())
	defer cancel()
	// However, we want to tag activity generated by this
	// LookupHost with the current dialID so we can always
	// explain why something is happening.
	child = WithDialID(child, ContextDialID(ctx))
	start := time.Now()
	go r.lookupHostWithChannel(child, hostname, ch)
	select {
	case out := <-ch:
		r.emitEvent(ctx, hostname, start, out.addrs, out.err)
		return out.addrs, out.err
	case <-ctx.Done():
		r.emitEvent(ctx, hostname, start, nil, ctx.Err())
		return nil, ctx.Err()
	}
}

type result struct {
	addrs []string
	err   error
}

func (r *Resolver) lookupHostWithChannel(
	ctx context.Context, hostname string, ch chan<- result,
) {
	addrs, err := r.resolver.LookupHost(ctx, hostname)
	ch <- result{addrs: addrs, err: err}
}

func (r *Resolver) emitEvent(
	ctx context.Context, hostname string,
	start time.Time, addrs []string, err error,
) {
	stop := time.Now()
	m := model.Measurement{
		Resolve: &model.ResolveEvent{
			Addresses: addrs,
			DialID:    ContextDialID(ctx),
			Duration:  stop.Sub(start),
			Error:     err,
			Hostname:  hostname,
			Time:      stop.Sub(r.beginning),
		},
	}
	r.handler.OnMeasurement(m)
}
